---
phase: 03-audio-core-polish
plan: 05
type: execute
---

<objective>
Integrate LUFS normalization into the playback pipeline.

Purpose: Apply LUFS-based gain compensation during audio playback when normalization is enabled.
Output: Updated playback stream creation that reads settings and applies LUFS gain.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-audio-core-polish/03-04-SUMMARY.md

**Prior decisions affecting this plan:**
- LUFS gain calculated once at stream creation, not per-sample
- Settings read from AppState at playback start
- Backward compatible: when disabled, behavior unchanged

**Relevant source files:**
@src-tauri/src/audio/playback.rs
@src-tauri/src/audio/manager.rs
@src-tauri/src/commands/audio.rs

**Constraints:**
- Must not break existing playback when normalization disabled
- LUFS gain applied multiplicatively with existing volume
- Performance: no per-sample settings lookup
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update playback stream to accept LUFS parameters</name>
  <files>src-tauri/src/audio/playback.rs</files>
  <action>
    1. Find create_playback_stream() or equivalent function that creates audio streams

    2. Add parameters for LUFS normalization:
       - `sound_lufs: Option<f32>` - from AudioData.lufs
       - `target_lufs: f32` - from settings
       - `enable_normalization: bool` - from settings

    3. Calculate LUFS gain once at stream creation:
       ```rust
       let lufs_gain = calculate_lufs_gain(sound_lufs, target_lufs, enable_normalization);
       ```

    4. Apply LUFS gain in the audio callback alongside existing volume:
       ```rust
       // Existing: scaled_volume = calculate_scaled_volume(volume)
       // New: final_volume = scaled_volume * lufs_gain
       let final_volume = scaled_volume * lufs_gain;
       ```

    5. Update any write_audio_* functions to use the combined gain

    Note: Review current volume application pattern and integrate LUFS gain appropriately.
  </action>
  <verify>`cargo check --manifest-path src-tauri/Cargo.toml` passes</verify>
  <done>Playback stream accepts and applies LUFS normalization parameters</done>
</task>

<task type="auto">
  <name>Task 2: Update AudioManager/commands to pass LUFS settings</name>
  <files>src-tauri/src/audio/manager.rs, src-tauri/src/commands/audio.rs</files>
  <action>
    1. In play_dual_output command (or equivalent):
       - Read settings from AppState:
         ```rust
         let settings = state.read_settings();
         let enable_normalization = settings.enable_lufs_normalization;
         let target_lufs = settings.target_lufs;
         ```

       - Get sound's LUFS value from AudioData (from cache):
         ```rust
         let sound_lufs = audio_data.lufs;
         ```

       - Pass to playback stream creation:
         ```rust
         create_playback_stream(
             audio_data,
             volume,
             device,
             sound_lufs,
             target_lufs,
             enable_normalization,
         )
         ```

    2. If AudioManager has intermediate methods, update their signatures too

    3. Ensure both primary and secondary output streams receive same LUFS gain
  </action>
  <verify>`cargo check --manifest-path src-tauri/Cargo.toml` passes</verify>
  <done>Commands pass LUFS settings to playback</done>
</task>

<task type="auto">
  <name>Task 3: Verify backward compatibility</name>
  <files>src-tauri/src/audio/playback.rs, src-tauri/src/commands/audio.rs</files>
  <action>
    1. Add integration test or manual verification logic:
       ```rust
       #[test]
       fn test_playback_unchanged_when_normalization_disabled() {
           // When enable_normalization = false:
           // - calculate_lufs_gain should return 1.0
           // - Final volume should equal scaled_volume (no LUFS adjustment)

           let lufs_gain = calculate_lufs_gain(Some(-20.0), -14.0, false);
           assert!((lufs_gain - 1.0).abs() < 0.0001, "Disabled normalization should not affect volume");
       }

       #[test]
       fn test_playback_unchanged_when_no_lufs_data() {
           // When sound has no LUFS (old cached data, silence, etc):
           // - Should not crash
           // - Should play at normal volume

           let lufs_gain = calculate_lufs_gain(None, -14.0, true);
           assert!((lufs_gain - 1.0).abs() < 0.0001, "Missing LUFS should not affect volume");
       }
       ```

    2. Verify compile-time that all code paths handle Option<f32> for LUFS

    3. Add tracing::debug for LUFS gain application:
       ```rust
       tracing::debug!(
           "Playback with LUFS gain: {:.2} (sound: {:?} LUFS, target: {} LUFS, enabled: {})",
           lufs_gain, sound_lufs, target_lufs, enable_normalization
       );
       ```
  </action>
  <verify>`cargo test --manifest-path src-tauri/Cargo.toml` passes</verify>
  <done>Backward compatibility verified, tests passing</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo check --manifest-path src-tauri/Cargo.toml` passes
- [ ] `cargo test --manifest-path src-tauri/Cargo.toml` all tests pass
- [ ] Playback works when normalization disabled (no change in behavior)
- [ ] Playback works when sound has no LUFS data (no crash, normal volume)
- [ ] LUFS gain logged in debug output
</verification>

<success_criteria>
- Playback stream applies LUFS gain when enabled
- Settings read from AppState at playback start
- Both primary and secondary outputs use same LUFS gain
- No behavior change when normalization disabled
- No crash when LUFS data missing
- All tests passing
</success_criteria>

<output>
After completion, create `.planning/phases/03-audio-core-polish/03-05-SUMMARY.md`

Include:
- Integration points modified
- Backward compatibility verified
- Debug logging examples
- Ready for Plan 06 (Frontend UI)
</output>
