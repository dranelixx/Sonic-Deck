---
phase: 03-audio-core-polish
plan: 02
type: execute
---

<objective>
Implement LUFS calculation during audio decode.

Purpose: Calculate integrated loudness when audio files are decoded, storing LUFS value in AudioData.
Output: calculate_lufs() helper function integrated into decode pipeline with unit tests.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-audio-core-polish/03-01-SUMMARY.md
@.planning/phases/03-audio-core-polish/03-RESEARCH.md

**Prior decisions affecting this plan:**
- Use ebur128::Mode::I for integrated loudness (most efficient)
- Filter out silence: lufs > -70.0 and is_finite()
- Handle mono audio properly (DualMono channel config)

**Relevant source files:**
@src-tauri/src/audio/decode.rs
@src-tauri/src/audio/mod.rs

**Constraints:**
- LUFS calculation must not slow down decode significantly
- Return None for invalid LUFS (silence, too short)
- Mono audio needs special handling to avoid -3 LU error
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create calculate_lufs() helper function</name>
  <files>src-tauri/src/audio/decode.rs</files>
  <action>
    1. Add import at top of decode.rs:
       ```rust
       use ebur128::{EbuR128, Mode};
       ```

    2. Add helper function:
       ```rust
       /// Calculate integrated loudness (LUFS) using EBU R 128 standard.
       ///
       /// Returns None if:
       /// - Audio is pure silence (LUFS < -70)
       /// - Calculation fails (invalid samples, too short)
       /// - Result is not a valid number (NaN, Infinity)
       ///
       /// For mono audio, measurement accounts for dual-speaker playback.
       pub(crate) fn calculate_lufs(samples: &[f32], sample_rate: u32, channels: u16) -> Option<f32> {
           // Need at least 100ms of audio for reliable measurement
           let min_samples = (sample_rate as usize * channels as usize) / 10;
           if samples.len() < min_samples {
               return None;
           }

           let mut ebur = EbuR128::new(channels as u32, sample_rate, Mode::I).ok()?;
           ebur.add_frames_f32(samples).ok()?;

           let lufs = ebur.loudness_global().ok()?;

           // Filter out silence and invalid values
           if lufs.is_finite() && lufs > -70.0 {
               Some(lufs as f32)
           } else {
               None
           }
       }
       ```

    Note: Per RESEARCH.md, mono channel configuration might need DualMono for accurate measurement.
    Start simple, add DualMono handling if tests show -3 LU discrepancy.
  </action>
  <verify>`cargo check --manifest-path src-tauri/Cargo.toml` passes</verify>
  <done>calculate_lufs() function implemented</done>
</task>

<task type="auto">
  <name>Task 2: Integrate LUFS calculation into decode pipeline</name>
  <files>src-tauri/src/audio/decode.rs</files>
  <action>
    1. Find where AudioData is constructed after decoding
    2. Calculate LUFS before constructing AudioData:
       ```rust
       let lufs = calculate_lufs(&samples, sample_rate, channels);

       if let Some(lufs_value) = lufs {
           tracing::debug!("Calculated LUFS: {:.1} for {} samples", lufs_value, samples.len());
       }
       ```

    3. Update AudioData construction to include lufs:
       ```rust
       Ok(AudioData {
           samples,
           sample_rate,
           channels,
           lufs,
       })
       ```

    4. Ensure waveform calculation (if in same file) still works
  </action>
  <verify>`cargo check --manifest-path src-tauri/Cargo.toml` passes</verify>
  <done>LUFS calculated during decode, stored in AudioData</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for LUFS calculation</name>
  <files>src-tauri/src/audio/decode.rs</files>
  <action>
    Add tests to the `#[cfg(test)]` module in decode.rs:

    ```rust
    // ========== LUFS calculation tests ==========

    #[test]
    fn test_calculate_lufs_returns_valid_range() {
        // Use existing test fixture
        let path = get_fixture_path("test_mono.mp3");
        let audio = decode_audio_file(path.to_str().unwrap()).unwrap();

        // LUFS should be present and in valid range
        assert!(audio.lufs.is_some(), "LUFS should be calculated for test fixture");
        let lufs = audio.lufs.unwrap();
        assert!(lufs >= -70.0 && lufs <= 0.0, "LUFS {} outside valid range [-70, 0]", lufs);
    }

    #[test]
    fn test_calculate_lufs_silence_returns_none() {
        // Pure silence should return None
        let silence = vec![0.0f32; 48000]; // 1 second at 48kHz mono
        let lufs = calculate_lufs(&silence, 48000, 1);
        assert!(lufs.is_none(), "Silence should return None");
    }

    #[test]
    fn test_calculate_lufs_short_audio_returns_none() {
        // Very short audio (< 100ms) should return None
        let short = vec![0.5f32; 1000]; // ~20ms at 48kHz
        let lufs = calculate_lufs(&short, 48000, 1);
        assert!(lufs.is_none(), "Very short audio should return None");
    }

    #[test]
    fn test_calculate_lufs_with_tone() {
        // Generate 1 second of 440Hz sine wave at -20 dBFS
        let sample_rate = 48000u32;
        let amplitude = 0.1f32; // ~-20 dBFS
        let samples: Vec<f32> = (0..sample_rate)
            .map(|i| amplitude * (2.0 * std::f32::consts::PI * 440.0 * i as f32 / sample_rate as f32).sin())
            .collect();

        let lufs = calculate_lufs(&samples, sample_rate, 1);
        assert!(lufs.is_some(), "Tone should have measurable LUFS");
        let lufs = lufs.unwrap();
        assert!(lufs > -40.0 && lufs < -10.0, "440Hz tone at -20dBFS should be around -20 to -30 LUFS, got {}", lufs);
    }
    ```
  </action>
  <verify>`cargo test --manifest-path src-tauri/Cargo.toml decode` passes all tests</verify>
  <done>LUFS calculation unit tests added and passing</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo check --manifest-path src-tauri/Cargo.toml` passes
- [ ] `cargo test --manifest-path src-tauri/Cargo.toml decode` passes
- [ ] calculate_lufs() handles silence correctly (returns None)
- [ ] calculate_lufs() handles short audio correctly (returns None)
- [ ] Test fixtures have LUFS values in valid range
</verification>

<success_criteria>
- calculate_lufs() implemented with proper validation
- LUFS calculated during decode pipeline
- AudioData.lufs populated for valid audio files
- Unit tests for edge cases (silence, short audio, normal audio)
- All tests passing
</success_criteria>

<output>
After completion, create `.planning/phases/03-audio-core-polish/03-02-SUMMARY.md`

Include:
- LUFS values observed for test fixtures
- Any edge cases discovered
- Test coverage impact
- Ready for Plan 03
</output>
