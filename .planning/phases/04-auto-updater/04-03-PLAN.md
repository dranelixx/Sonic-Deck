---
phase: 04-auto-updater
plan: 03
type: execute
---

<objective>
CI/CD für Updater-Artefakte konfigurieren und End-to-End testen.

Purpose: Release-Workflow generiert latest.json und signierte Installer für Auto-Updates.
Output: Funktionierender Update-Flow von GitHub Release zu App.

**Branch:** `feature/auto-updater` (weiter auf bestehendem Branch, am Ende PR zu develop)
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-auto-updater/04-CONTEXT.md
@.planning/phases/04-auto-updater/04-RESEARCH.md
@.planning/phases/04-auto-updater/04-01-SUMMARY.md
@.planning/phases/04-auto-updater/04-02-SUMMARY.md

**Pitfalls aus RESEARCH.md:**
- Signing Key Confusion: Tauri-Signing (Ed25519) ≠ Windows Code Signing
- TAURI_SIGNING_PRIVATE_KEY muss als GitHub Secret gesetzt sein
- latest.json muss NSIS-Installer referenzieren

**Relevant source files:**
@.github/workflows/release.yml
@src-tauri/tauri.conf.json
</context>

<tasks>

<task type="checkpoint:human-action" gate="blocking">
  <action>Tauri Signing Keys generieren und als GitHub Secret speichern</action>
  <instructions>
    Ich kann die Keys nicht für dich generieren (erfordert lokale CLI und GitHub-Zugang).

    **Schritte:**

    1. Keys generieren (im Terminal):
       ```bash
       npx tauri signer generate -w ~/.tauri/sonicdeck.key
       ```
       Dies erstellt:
       - Private Key: ~/.tauri/sonicdeck.key
       - Public Key: ~/.tauri/sonicdeck.key.pub

    2. Public Key kopieren:
       ```bash
       cat ~/.tauri/sonicdeck.key.pub
       ```
       → Diesen Key brauche ich für tauri.conf.json

    3. Private Key als GitHub Secret speichern:
       - Gehe zu: https://github.com/DraneLixX/SonicDeck/settings/secrets/actions
       - "New repository secret" klicken
       - Name: TAURI_SIGNING_PRIVATE_KEY
       - Value: Inhalt von ~/.tauri/sonicdeck.key (gesamte Datei)

    4. Optional: Password Secret (wenn bei Generierung gesetzt)
       - Name: TAURI_SIGNING_PRIVATE_KEY_PASSWORD
       - Value: Das gewählte Password

    **WICHTIG:**
    - Private Key NIEMALS committen!
    - Public Key ist öffentlich, wird in tauri.conf.json gespeichert
  </instructions>
  <verification>
    - ~/.tauri/sonicdeck.key.pub existiert
    - GitHub Secret TAURI_SIGNING_PRIVATE_KEY ist gesetzt
  </verification>
  <resume-signal>Antworte mit dem PUBLIC KEY (beginnt mit "dW50cnVzdGVk...") damit ich ihn in tauri.conf.json eintragen kann</resume-signal>
</task>

<task type="auto">
  <name>Task 2: Public Key in tauri.conf.json eintragen</name>
  <files>src-tauri/tauri.conf.json</files>
  <action>
    Den vom User bereitgestellten Public Key im plugins.updater.pubkey Feld eintragen.

    Der Placeholder "PLACEHOLDER_PUBKEY" wird durch den echten Key ersetzt.

    WICHTIG: Exakt den bereitgestellten Key verwenden, keine Modifikation.
  </action>
  <verify>tauri.conf.json ist valides JSON</verify>
  <done>Echter Public Key in Konfiguration eingetragen</done>
</task>

<task type="auto">
  <name>Task 3: Release Workflow für Updater-Artefakte anpassen</name>
  <files>.github/workflows/release.yml</files>
  <action>
    Release Workflow erweitern:

    1. Environment Variables für Signing hinzufügen:
       ```yaml
       env:
         GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
         TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
         TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
       ```

    2. latest.json zu Release-Artefakten hinzufügen:
       ```yaml
       files: |
         src-tauri/target/release/bundle/msi/*.msi
         src-tauri/target/release/bundle/nsis/*.exe
         src-tauri/target/release/bundle/nsis/*.exe.sig
         src-tauri/target/release/bundle/nsis/latest.json
       ```

    WICHTIG:
    - Bestehende Workflow-Struktur beibehalten
    - NSIS-Artefakte (.exe, .exe.sig) für Updater verwenden
    - latest.json wird automatisch generiert wenn createUpdaterArtifacts: true
  </action>
  <verify>YAML-Syntax ist valide (yamllint oder CI-Preview)</verify>
  <done>Workflow lädt Updater-Artefakte zu GitHub Release hoch</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Auto-Updater Infrastruktur (Backend, Frontend, CI/CD)</what-built>
  <how-to-verify>
    **Test-Szenario:** Simulierter Update-Check

    1. App starten: `yarn tauri dev`
    2. Nach 3 Sekunden: Console checken für Update-Check Log
       - Erwartet: "Update check failed" oder "No update available" (normal, kein Release mit latest.json)
    3. Header prüfen: Kein Badge sichtbar (korrekt, kein Update)

    **Optionaler Full-Flow Test (wenn Zeit):**
    1. Testversion bauen mit niedrigerer Version
    2. GitHub Release erstellen mit höherer Version
    3. App starten → Badge sollte erscheinen
    4. Update installieren → App restartet

    **Wichtig für später:**
    - Erst nach erstem echten Release mit latest.json funktioniert der volle Flow
    - Aktueller Test validiert nur dass keine Crashes auftreten
  </how-to-verify>
  <resume-signal>Type "approved" wenn App startet und keine Errors wirft, oder beschreibe Probleme</resume-signal>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] Public Key in tauri.conf.json (nicht mehr PLACEHOLDER)
- [ ] GitHub Secret TAURI_SIGNING_PRIVATE_KEY existiert
- [ ] release.yml enthält Signing-Env-Vars und latest.json Upload
- [ ] yarn tauri dev startet ohne Fehler
- [ ] Keine Console-Errors beim Update-Check
</verification>

<success_criteria>
- Alle Tasks abgeschlossen
- Alle Verifikationen bestanden
- Signing-Keys generiert und konfiguriert
- CI/CD lädt Updater-Artefakte hoch
- App führt Update-Check durch ohne Crash
- Phase 4 complete
</success_criteria>

<output>
After completion, create `.planning/phases/04-auto-updater/04-03-SUMMARY.md`
</output>
